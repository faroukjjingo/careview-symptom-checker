import { symptomCombinations } from './SymptomCombinations';
import { symptomWeights } from './SymptomWeights';
import riskFactorWeights from './RiskFactorWeights';
import travelRiskFactors from './TravelRiskFactors';
import drugHistoryWeights from './DrugHistoryWeights';
import { GoogleGenerativeAI } from '@google/generative-ai';

const CONFIDENCE_THRESHOLDS = {
  HIGH: 0.7,
  MEDIUM: 0.4,
};

const redFlagSymptoms = [
  'chest pain',
  'shortness of breath',
  'severe headache',
  'sudden vision loss',
  'hemoptysis',
  'severe abdominal pain',
];

// Initialize Gemini API (replace with your API key)
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Helper functions (unchanged)
const normalizeDuration = (duration, unit) => {
  const multipliers = { days: 1, weeks: 7, months: 30 };
  return duration * (multipliers[unit.toLowerCase()] || 1);
};

const categorizeAge = (age) => {
  const ageNum = parseInt(age);
  if (ageNum <= 12) return 'child';
  if (ageNum <= 18) return 'adolescent';
  if (ageNum <= 65) return 'adult';
  return 'elderly';
};

const calculateModifiers = (data, factors) => {
  return (
    (data.durationFactors?.[factors.duration] || 1) *
    (data.severityFactors?.[factors.severity] || 1) *
    (data.ageFactors?.[factors.ageGroup] || 1) *
    (data.genderFactors?.[factors.gender] || 1)
  );
};

const normalizeScore = (score, maxScore) => {
  return Math.min(100, Math.max(0, (score / maxScore) * 100));
};

const getConfidenceLevel = (probability) => {
  if (probability >= CONFIDENCE_THRESHOLDS.HIGH) return 'High';
  if (probability >= CONFIDENCE_THRESHOLDS.MEDIUM) return 'Medium';
  return 'Low';
};

async function enhanceWithGemini(symptoms, patientFactors, initialDiagnoses, unmatchedSymptoms) {
  try {
    const model = genAI.getGenerativeModel({ model: 'gemini-1.5-pro' });
    const prompt = `
      You are a medical diagnosis assistant. Given the following patient data and initial diagnoses from a rule-based system, validate and enhance the results. Suggest additional diagnoses for unmatched symptoms, adjust probabilities if necessary, and provide a brief explanation for each diagnosis. Return results in JSON format.

      Patient Data:
      - Symptoms: ${symptoms.join(', ')}
      - Age: ${patientFactors.age} (${patientFactors.ageGroup})
      - Gender: ${patientFactors.gender}
      - Duration: ${patientFactors.duration} ${patientFactors.durationUnit} (${patientFactors.durationCategory})
      - Severity: ${patientFactors.severity}
      - Travel Region: ${patientFactors.travelRegion || 'None'}
      - Risk Factors: ${patientFactors.riskFactors.join(', ') || 'None'}
      - Drug History: ${patientFactors.drugHistory || 'None'}

      Initial Diagnoses:
      ${JSON.stringify(initialDiagnoses, null, 2)}

      Unmatched Symptoms (not in rule-based weights):
      ${unmatchedSymptoms.join(', ') || 'None'}

      Tasks:
      1. Validate initial diagnoses and adjust probabilities if needed.
      2. Suggest diagnoses for unmatched symptoms.
      3. Provide a brief explanation for each diagnosis.
      4. Return results in this format:
      {
        "diagnoses": [
          {
            "diagnosis": "disease name",
            "probability": number (0-100),
            "confidence": "High|Medium|Low",
            "explanation": "Reason for this diagnosis",
            "source": "Rule-Based|Gemini"
          }
        ]
      }
    `;

    const result = await model.generateContent(prompt);
    const responseText = await result.response.text();
    const enhancedResults = JSON.parse(responseText);
    return enhancedResults.diagnoses;
  } catch (error) {
    console.error('Gemini API error:', error);
    return initialDiagnoses.map((d) => ({
      ...d,
      source: 'Rule-Based',
      explanation: 'Generated by rule-based system',
    }));
  }
}

const calculateDiagnosis = async (
  symptoms,
  duration,
  durationUnit,
  severity,
  age,
  gender,
  drugHistory,
  travelRegion,
  riskFactors
) => {
  try {
    // Input validation
    if (!symptoms || symptoms.length === 0) {
      return { error: 'Please select at least one symptom' };
    }

    // Normalize inputs
    const normalizedDuration = normalizeDuration(duration, durationUnit);
    const durationCategory =
      normalizedDuration <= 3 ? 'short' : normalizedDuration <= 14 ? 'medium' : 'long';
    const ageGroup = categorizeAge(age);
    const factors = {
      duration: durationCategory,
      severity: severity.toLowerCase(),
      ageGroup,
      gender: gender.toLowerCase(),
      durationUnit,
      age,
      travelRegion,
      riskFactors: riskFactors || [],
      drugHistory,
    };

    // Initialize disease scores
    const diseaseScores = {};
    const matchingFactors = {
      combinationMatches: [],
      symptomMatches: [],
      riskFactorMatches: [],
      travelRiskMatches: [],
      drugHistoryMatches: [],
    };
    const unmatchedSymptoms = [];

    // Step 1: Score individual symptoms
    let symptomMatchScore = 0;
    for (const symptom of symptoms) {
      if (symptomWeights[symptom]) {
        matchingFactors.symptomMatches.push(symptom);
        const diseases = symptomWeights[symptom];
        for (const [disease, data] of Object.entries(diseases)) {
          if (!diseaseScores[disease]) {
            diseaseScores[disease] = { score: 0, factors: {} };
          }
          const baseScore = data.weight || 1;
          const modifiers = calculateModifiers(data, factors);
          const symptomScore = baseScore * modifiers * 10;
          diseaseScores[disease].score += symptomScore;
          diseaseScores[disease].factors[`symptom_${symptom}`] = baseScore;
          symptomMatchScore += symptomScore;
        }
      } else {
        unmatchedSymptoms.push(symptom);
      }
    }

    if (unmatchedSymptoms.length > 0) {
      console.warn('Unmatched symptoms:', unmatchedSymptoms);
    }

    // Step 2: Score combinations
    const symptomSet = new Set(symptoms);
    const combinationKeys = Object.keys(symptomCombinations);
    let combinationMatchScore = 0;

    for (const comboKey of combinationKeys) {
      const comboSymptoms = comboKey.split(', ').map((s) => s.trim());
      const intersection = comboSymptoms.filter((s) => symptomSet.has(s));
      const matchRatio = intersection.length / comboSymptoms.length;

      if (intersection.length >= Math.min(2, comboSymptoms.length)) {
        const isExactMatch = intersection.length === comboSymptoms.length;
        matchingFactors.combinationMatches.push({
          combination: comboKey,
          matchedSymptoms: intersection,
          isExactMatch,
        });

        const diseases = symptomCombinations[comboKey];
        for (const [disease, weight] of Object.entries(diseases)) {
          if (!diseaseScores[disease]) {
            diseaseScores[disease] = { score: 0, factors: {} };
          }
          const comboScore = weight * matchRatio * (isExactMatch ? 50 : 30);
          diseaseScores[disease].score += comboScore;
          diseaseScores[disease].factors[`combo_${comboKey}`] = weight;
          combinationMatchScore += comboScore;
        }
      }
    }

    // Steps 3-5: Apply risk factors, travel risks, drug history (unchanged)
    let riskFactorMatchScore = 0;
    if (riskFactors && riskFactors.length) {
      for (const factor of riskFactors) {
        if (riskFactorWeights[factor]) {
          matchingFactors.riskFactorMatches.push(factor);
          const diseases = riskFactorWeights[factor];
          for (const [disease, weight] of Object.entries(diseases)) {
            if (!diseaseScores[disease]) {
              diseaseScores[disease] = { score: 0, factors: {} };
            }
            const riskScore = weight * 5;
            diseaseScores[disease].score += riskScore;
            diseaseScores[disease].factors[`risk_${factor}`] = weight;
            riskFactorMatchScore += riskScore;
          }
        }
      }
    }

    let travelRiskMatchScore = 0;
    if (travelRegion && travelRiskFactors[travelRegion]) {
      matchingFactors.travelRiskMatches.push(travelRegion);
      const diseases = travelRiskFactors[travelRegion];
      for (const [disease, weight] of Object.entries(diseases)) {
        if (!diseaseScores[disease]) {
          diseaseScores[disease] = { score: 0, factors: {} };
        }
        const travelScore = weight * 5;
        diseaseScores[disease].score += travelScore;
        diseaseScores[disease].factors[`travel_${travelRegion}`] = weight;
        travelRiskMatchScore += travelScore;
      }
    }

    let drugHistoryMatchScore = 0;
    if (drugHistory && drugHistoryWeights[drugHistory]) {
      matchingFactors.drugHistoryMatches.push(drugHistory);
      const diseases = drugHistoryWeights[drugHistory];
      for (const [disease, weight] of Object.entries(diseases)) {
        if (!diseaseScores[disease]) {
          diseaseScores[disease] = { score: 0, factors: {} };
        }
        const drugScore = weight * 3;
        diseaseScores[disease].score += drugScore;
        diseaseScores[disease].factors[`drug_${drugHistory}`] = weight;
        drugHistoryMatchScore += drugScore;
      }
    }

    // Step 6: Check red flags
    const hasRedFlag = symptoms.some((symptom) => redFlagSymptoms.includes(symptom));

    // Step 7: Generate initial results
    const maxPossibleScore = 1000;
    let detailed = Object.entries(diseaseScores)
      .map(([disease, data]) => {
        let score = data.score;
        const isRedFlagDisease = [
          'heart attack',
          'pulmonary embolism',
          'meningitis',
          'appendicitis',
        ].includes(disease);
        if (hasRedFlag && isRedFlagDisease) {
          score *= 1.5;
        }

        const probability = normalizeScore(score, maxPossibleScore) / 100;
        return {
          diagnosis: disease,
          probability: Math.round(probability * 100 * 10) / 10,
          confidence: getConfidenceLevel(probability),
          matchingFactors: {
            symptomMatch: matchingFactors.symptomMatches.join(', ') || 'None',
            riskFactorMatch: matchingFactors.riskFactorMatches.join(', ') || 'None',
            travelRiskMatch: matchingFactors.travelRiskMatches.join(', ') || 'None',
            drugHistoryMatch: matchingFactors.drugHistoryMatches.join(', ') || 'None',
            combinationMatches: matchingFactors.combinationMatches.map((c) => ({
              combination: c.combination,
              matchedSymptoms: c.matchedSymptoms.join(', '),
              isExactMatch: c.isExactMatch,
            })),
          },
          source: 'Rule-Based',
          explanation: 'Generated by rule-based system',
        };
      })
      .sort((a, b) => b.probability - a.probability);

    // Fallback if no results
    if (detailed.length === 0) {
      const fallbackDiagnoses = [];
      symptoms.forEach((symptom) => {
        if (symptomWeights[symptom]) {
          Object.keys(symptomWeights[symptom]).forEach((disease) => {
            if (!fallbackDiagnoses.some((d) => d.diagnosis === disease)) {
              fallbackDiagnoses.push({
                diagnosis: disease,
                probability: 1,
                confidence: 'Low',
                matchingFactors: {
                  symptomMatch: symptom,
                  riskFactorMatch: 'None',
                  travelRiskMatch: 'None',
                  drugHistoryMatch: 'None',
                  combinationMatches: [],
                },
                source: 'Rule-Based',
                explanation: 'Fallback diagnosis based on single symptom',
              });
            }
          });
        }
      });
      if (fallbackDiagnoses.length > 0) {
        detailed = fallbackDiagnoses;
      } else {
        return { error: 'No diagnoses found; symptom weights may be incomplete' };
      }
    }

    // Step 8: Enhance with Gemini
    const enhancedDiagnoses = await enhanceWithGemini(symptoms, factors, detailed, unmatchedSymptoms);

    // Merge results, prioritizing rule-based diagnoses
    const finalDiagnoses = enhancedDiagnoses.reduce((acc, geminiDiagnosis) => {
      const existing = acc.find((d) => d.diagnosis === geminiDiagnosis.diagnosis);
      if (existing) {
        // Blend probabilities (e.g., 70% rule-based, 30% Gemini)
        existing.probability = Math.round(
          existing.probability * 0.7 + geminiDiagnosis.probability * 0.3
        );
        existing.confidence = getConfidenceLevel(existing.probability / 100);
        existing.explanation = `${existing.explanation}; Gemini: ${geminiDiagnosis.explanation}`;
      } else if (geminiDiagnosis.source === 'Gemini') {
        acc.push({
          ...geminiDiagnosis,
          matchingFactors: {
            symptomMatch: unmatchedSymptoms.join(', ') || symptoms.join(', '),
            riskFactorMatch: matchingFactors.riskFactorMatches.join(', ') || 'None',
            travelRiskMatch: matchingFactors.travelRiskMatches.join(', ') || 'None',
            drugHistoryMatch: matchingFactors.drugHistoryMatches.join(', ') || 'None',
            combinationMatches: matchingFactors.combinationMatches,
          },
        });
      }
      return acc;
    }, detailed);

    return {
      detailed: finalDiagnoses.slice(0, 5),
      redFlag: hasRedFlag
        ? 'Urgent: Seek immediate medical attention due to critical symptoms.'
        : null,
    };
  } catch (error) {
    console.error('Calculation error:', error);
    return { error: `Error calculating diagnosis: ${error.message}` };
  }
};

export default calculateDiagnosis;